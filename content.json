[{"title":"记录一次对话","date":"2018-01-28T09:35:17.000Z","path":"2018/01/28/记录一次对话/","text":"记一次与大佬的对话酒足饭饱后: 大佬:你们还没走呢？ 同事a:对啊,继续加班,上个月加了100个小时的班. 我:最近猝死率那么高,你就不怕猝死吗？ 同事a:想死？哪有那么容易？ 我:你平时不看新闻吗？ 同事a:不看 我:..... 同事b:我有一个朋友在某为,他说他们那里每隔一段时间都有人猝死！ 大佬:我有朋友去华为面试,入职的时候当场就发了睡袋. 我:... 大佬:不过最近听说高级了,不发睡袋了,桌子抽出来就是床. 我:...某为是强制加班吗？ 大佬:不是的,跟我们一样. 我:那为什么不走啊？ 大佬:只要你脸皮够厚,你可以走啊.其实华为内部竞争很激烈的,真的比国企竞争都激烈,你不努力,别看你刚进去工资很高,三五年之后,你工资还是那么点,这你还觉得高吗? 我:... 大佬:某为内部评级很严格的,所以大家都加班,你不加班,你自己呆在那里都不好意思.那些猝死的都是一点都不休息的,只要你感觉你的身体不对劲，就赶紧去休息,别硬撑着.一般没事... 我:这么惨烈,看来我这辈子是没机会进某为了 我:大佬你工作几年了? 大佬:七八年了吧 同事a:大佬是真的牛x,拿到代码，上来就可以改人家底层(各种...) 大佬:中国就是那样,写代码就是我抄点你的,你抄点我的,cv来cv去,一般入行三五年都要有自己的职业规划,你不可能敲10年的代码的 我:为什么？ 大佬:国外还有可能,国内是基本不可能的.你看咱们现在写代码,不就是cv,你10年经验可以干,随便找一个二三年的也可以干,为什么要找你十年的呢，所以说，干一段时间都要有自己的规划的 大佬:你看他们整天拿本spring实战都来读去,其实也没多少长进,现在不是有那个github吗？那上面好多项目,没事照着敲一敲,看书你知道这个配置文件有什么用,只有自己用过了才知道,没事还是要提升代码量,代码量上不去,一切都是白谈. 第一次体会到:与君一席话胜读十年书. 孤独是给你思考自己的时间，在一个人的日子里，你要做的只有一件事，把自己变的更优秀","tags":[{"name":"记事","slug":"记事","permalink":"https:fengjisen.github.io/tags/记事/"}]},{"title":"2018","date":"2018-01-21T15:22:40.000Z","path":"2018/01/21/2018/","text":"马上就要毕业了。 感觉自己的大学挺遗憾的,还没好好感受就过去了. 但现在很明显不是缅怀过去的时候(拒绝了公司的三方协议) 这就意味着我要尽快找到下一家公司,至于拒绝的原因无非就是工资低,待遇不好,再加上一条不能融入企业文化吧 独自走路是很容易往后看！惋惜以前的种种,这总是很让我负能量，希望以后可以有人陪我一起走吧 总结一下我玩博客的三个阶段吧 first:当初在实验室,大家都在搞hexo+github搭建自己的博客,感觉很有趣就模仿网上的教程，自己弄了一个，就是目前的这个 next:由于hexo+github搭建的博客是静态的，有违于自己后端的身份,balabala...服务器`域名等等,信心满满的准备开始写博客...奈何造化弄人,不知道自己写的后台哪里有问题，数据库总是莫名其妙的崩掉，解决了几次，再加上域名备案问题...彻底放弃 finally:也就是现在了，最近复习以前的知识，发现好多都忘了(也不知道是记得不牢固还是根本就没记住),所以决定还是以后没事可以写点生活啊技术的什么东西,权且作为备忘录... 去培训的同学也都已结束找到了月薪上万的工作了...不知道我当初选择这条路究竟是对是错.不过至少不会算错吧 最近比较心烦.前端不会 这段时间要补补前端了 这要归功于朋友的一句话,只要你感兴趣,哪会没时间呢 突然间茅塞顿开... 今天先到这里吧 路很长 慢慢走","tags":[{"name":"记事","slug":"记事","permalink":"https:fengjisen.github.io/tags/记事/"}]},{"title":"程序员风格的修真小说","date":"2017-06-05T13:26:26.000Z","path":"2017/06/05/程序员风格的修真小说/","text":"知乎奇文终有一天我手中的编译器将成为我灵魂的一部分，这世界在我的眼中将被代码重构，我将看到山川无尽银河无垠都汇成二进制的数字河流，过往英雄都在我脑海眼前一一浮现，而我听到无数码农跪倒在我的程序面前呼喊。 他们叫我代码之神。 到那个时候，我想我一定可以找回你。 一丶 这是一个属于代码的修真世界。 这世界里的每一个人，每一个东西，包括高山大海，刀剑风云，其本质都是一串数字流。 打个比方，如果你知道一块石头的内部数据结构，并且参透其中玄妙，你就能用程序改变它的一切。如果能参透自身这一个复杂的操作系统，就能重新编码自己，获得更大的能力。 所以你的程序水平的高低，决定了你的牛逼程度。 我们这些修真者，都叫程序员。 有人的地方，就有江湖。有江湖的地方，就有代码。 刚入门的时候，师傅跟我说，我们程序员修的，是一份境界。短短几句的代码里，要有最完美的逻辑，跟最精妙的算法。这本《算法导论》，你暂且拿去研修。 我们程序员，外修语言，内修算法。以数据为根，算天算地算自己。 听起来真的好酷。 但这个江湖，并不平静。几大门派，上有微软谷歌，下至百度阿里，每个门派风格迥异，暗地里都有无数摩擦。 师傅说，我们知乎派，理论见长。三大软狗、哦不，三大软神坐镇，还有无数默默搬砖的程序员，如今也算在乱世立稳了脚跟。 师傅还说，江湖虽乱，但我们修真之人，说到底还是要修自身，恩恩怨怨都是过眼云烟，自身境界才是万源之本。 我点了点头。 师傅又拍了拍我的小脑瓜，慈祥一笑。他说，如果下次天涯派那群人还过来闹事，我们一定要秉承我们的自身理念来处理他们。 我知道了，我回师傅道，我跟刘看山一定会好言相劝，么么他们个哒哒。 不。师傅转身过来，鹰眼之中精光毕露，胡须颤动的嘴唇之中，一个字一个字地吐出来。 灰飞烟灭，一个不留。 二丶 自我开始修真起，我练的便是C++的功夫。 虽然大师兄跟我说过，不管你学的事什么语言，都是殊途同归。我们修真之人，都不要在乎这些差别，要参透的是程序的本质。 然后他又说，不过，用Java的都是傻逼。 大师兄跟我一样，C++的功底深厚，面向对象的各种技能用的精通，只是可惜，他还没有对象。 我永远忘不了那一天，我们知乎派的山门被一众凶恶之徒所踏破，山石飞舞，浮尘弥漫，门派服务器都暂停运行。 大师兄坐在大殿房顶之上，喝一壶陈年的竹叶青。姿势潇洒，闷骚至极。 是他们，谁都知道，天涯派不止一次来闹事。 我从来没见过大师兄出过手。 天涯派的来人，在烟尘之中现出数个魁梧身影，还夹带了一声大笑和开场白： 哈哈哈哈哈哈哈，知乎派，hello world！ 大师兄的眼皮都没有眨一下。 他的右手之上字符串环流浮现，左手抬起酒壶一饮而尽，右手对着虚空就是一指，那一串字符都消散在空气之中。 刹那间风云突变，一阵狂风似有形一般，沿着大师兄所指方向似一条狂龙横冲了过去，一个照面便将几个大汉吹得撞出山门之外，摔了个七荤八素。 那一霎我屏住呼吸。 大师兄整了整风中凌乱的发型，说，这就叫快速傅里叶变换，将风压重新编码，所到之处，寸草不生。你们都还在解码自己，我已经开始操纵世界——天涯跟知乎，就是在这里的差距，懂？ 都他妈的给老子滚。 从那一刻开始，我才知道，有些人已经可以编码这个世界本身。 这才是叫修真。 三丶 在知乎里修行了十年，师傅说我可以下山了。 我已经熟知C++的基本技能，但师傅告诫我千万不要说自己精通C++。他说，这世界上，没有人可以说，他已经精通C++，所以即算你装逼的时候，也要装得像个样子。比如，你可以说你精通java。 我点头称是。 这十年来，我每日苦读《算法导论》和《C++ primer》，精通数据库原理跟操作系统，同龄人之中无人是我敌手，自认为天下哪里都可去得。 是为年轻气盛，是为势不可挡。 我下山之后，连连在江湖之中，将一些有一点点小名气的程序员斩于马下。 他们之中，有些是根基不稳，有些是反应迟钝，有些是冥顽不灵，有些是莽撞愚蠢。 当然，我现在说起来是云淡风轻，那是因为我在装逼。其实也经过了一番苦战，有过一些辛酸。终于有一天，我将天下程序员排行榜第一千位的马特给击败，成功登上天下程序员排行榜。 马特这个程序员，有一些狡猾。他占据第一千位，已经很久没有变过。他精通计算机图形学，经常使用一些幻境击败对手。他比他上面几位更加难缠，所以通常没有人会去挑战他。因为你赢了他，也只能到第一千位，还不如去挑战他上面的更划算一些。 可惜他遇到了我，因为我比他，更精通计算机图形学。 于是这也成为一个不大不小的消息，在江湖里传播，从此我有了一个外号，他们叫我杀马特。 俗话说树大招风，人不能太出名。 有一天看到一个酒馆，我走进去，一个风情万种的女人转过来，她问我，客官，你要喝点什么嘛？ 我说，三两竹叶青。 正当我在喝酒的时候，来了一群穿着黑衣的程序员。 这群人，个个怪异，但水平很高。 江湖之中，穿黑衣的程序员，都叫黑客。 来者不善。 他们将我围起来，为首的一人说，他们是做安全的。 我心中陡然一惊。因为我看到了他们衣服里藏着的，三百六十度的环形刀刃。 一百年前，有一个叫奇虎的门派。他们每个人，都有一把神秘的三百六十度的环形刀刃，所以也叫奇虎三六零。他们声称他们的存在，是为了防止世界被破坏，为了保护世界的和平，是为了贯彻爱与真实的勇敢，他们是穿梭在江湖中的三六零。但他们却暗中做了无数秘密勾当，后来江湖人人称之魔教，BAT三大派跟一些其他门派联手围上光明顶，将其灭门。 当然，我们知乎派，也在之中出了不少的力量。 我皱眉喝酒，问他们所为何事。 那为首一人，拿过我的酒壶，仰头一灌。最后一滴酒在壶中滴落之时，无数环形刀刃在我身边出现，他的手中也倏地出现一把，朝我迎面砍来。 竟是偷袭。 刀刃之上闪过的代码我毕生未见，锋利无比，威力惊人。 我虽鼓动全身能量，瞬间编译，但也感觉凶多吉少。 这电光火石一瞬间，只听得铛地一声，数把环形刀刃通通弹落一边，那些黑衣怪人通通倒地。 我靠，我有这么强？ 只听得酒馆二楼悠悠传来一个女声。要打去别的地方打吧，进来酒钱都没付，还要打我的客人，这是何理？ 原来是酒馆的女老板。 她从二楼飘飘而落，将我身边灰尘一扫而空，朱唇轻启，哎呀，吓到小哥你了，真是对不起。 我以前听师傅说，对于程序员，只有两种东西是天敌。一种是御姐，一种是萝莉。我说我不信。 我现在信了。 四丶 女老板说，可以叫她结衣。 她问我叫什么，我嘟哝了半天，我说我叫杀马特。 结衣说哈哈哈哈哈哈哈你真可爱。 我说结衣，你怎么会这么强。 她说你不懂，我一个弱女子，不懂点编程之术，在这江湖里怎么开酒馆嘛。 我说结衣，你怎么这么好看。 结衣不说话了。 结衣说，你这个小流氓。 我说结衣，师傅说，我们程序员只有两种天敌，一叫御姐，二是萝莉，你是哪一种？ 结衣说，我都不是。 我说，哦。其实我心里想着的，是你都是。 结衣，你跟我一起闯荡江湖去好不好？ 不好，你还没我强。 哦。那等我比你强了，我们一起去闯荡江湖好不好？ 结衣笑了一下说，不好。 于是我就住在了酒馆里。 因为我可能，爱上了这个女人。 我杀马特曾经以为，我这一辈子就只能爱上一个女人。后来我才知道，这世间有万千代码，万物都可编译，但你编译不了的，是自己的心。 结衣是一个看上去很好强，八面玲珑的女人。她的编程水平，比那些排行榜上五百位之后的怂蛋，不知道高到哪里去了，但是她却在这里经营一个小酒馆。 我曾经问过为什么，但是结衣不说。 她只说她在等人。 我想问她是不是在等她的意中人，但是又不好意思开口。我怕是的，那我可能要伤心。师傅说修真的程序员，不能伤心。伤心的程序员，写不出好的代码。 所以我也只能等。 终于等到有一天，那天酒馆外面都是黑漆漆的云，空气里都是紧张的、像墨水混合了砂子一样的味道。可能有沙尘暴。 结衣一脸严肃。 我说结衣，咱们把门关上避一避。 结衣一言不发，站在门口，看向远方。 过了一阵，远处黑云之中，竟然出现一个人影。霎时间，雷光闪动，暴雨如注。 结衣看了我一眼，转身腾空就飞了出去。朝着远处的黑云人影，鼓动着浑身能量，就这么飞了出去。 我大喊一声结衣，然后也跑了出去。雨越下越大，我只能隐隐看见远处电闪雷鸣，我在混乱之中大喊结衣。 他们在交战。 远处代码一行行在云端飞舞盘旋，命令与字节化为巨大的力量，我没有想到结衣竟然强到这个地步。 举手投足，山河变色。 我想起大师兄所说的，有人还在解码自身，有人已经操纵世界。 是一场恶战。 我只能站在下面看，我甚至都不知道他们交战的具体情况。 我心急如焚。 在一个天际的惊雷响彻之后，一道正弦函数冲击波将所有黑云弹射开来，而我只看到结衣在空中坠落的身影。 拨云见日，阳光普照。 在很多年之后，当我再回想起这个情形，还是觉得，即算是临死之时的结衣，在空中的身影，也那么美好。 我抱着结衣，泣不成声。 她看着我，怔怔的看着我。 她说你别哭，真的，这是注定的一天。 她说我们家以前侵入国防系统，被朝廷发现灭门，我侥幸逃脱。但是不管我在哪里，总有一天他们会找上来。 她说你是男孩子，要坚强一点。不坚强一点，你怎么成为最好的程序员。 结衣在那几分钟里，好像想把她一生没讲完的话，都给讲完。 她说的最后一句话是，杀马特，你一定不要忘了我。 然后她就再也没有说话了。 我甚至都没有问过她说，你有心上人吗？ 我甚至都没有跟她说过，我是真的很喜欢你。 我甚至都没有吻过她，没有牵过她的手，我们只是这样匆匆遇到，然后匆匆告别。 她的身体将化成一串数字流，失去结构，流向无尽的原野、河流跟大地，化为三月的春风、杨柳跟雨滴。 有些东西，是命。 我的整个程序员修真生涯，在这一天，被分割开来。 对，我杀马特，在这一天之后，是一个一定要成为天下第一的程序员。 为了结衣。 五丶 并非是单单想给结衣报仇。 我们程序员的修真之路，内修自己，外修天地。 当代码可以操控天地这个最为复杂的系统之时，就一定会涉及到世界的本源之处。若这个世界的代码在我眼前一览无遗，或许我可以控制时间。 或许我可以从时间的bug里，找回结衣。 这是我这么多年来的，唯一念想。 毕竟我们程序员，生来就要逆天改命。 之后的时间里，我从程序员排行榜上一路飙升，五年之后跻身前十，成为世界上最优秀的程序员之一。 我树敌无数，也击败无数敌人。他们之中，甚至有自创一门语言的奇才，有号称已然精通C++的装逼犯，有对各类操作系统跟编译原理都熟悉无比的怪才，但是，不管谁，都无法阻挡我杀马特的脚步。 无人可挡。生来彷徨。 但，即算是到了我这样的水准，我也依旧无法知道，如何寻找这个世界里时间的bug，甚至都没有一丝头绪。 每逢debug的夜晚，我都会想起结衣，明媚如歌的笑容，和她从天而落，如佛光普照般的美丽。 但这又时时提醒了我，我可能真的已经离她远去了，而我无能为力。 这世间我认识的高手，都无法为我解答这个问题。 直到有一天，我在山间遇到一个红衣人。 他是个高手，从看到他码出第一行代码的时候，我就知道，这是个绝顶高手。 山野相逢，抛却了身份。我跟他把酒言欢，知无不谈，倒也痛快。 直到我跟他说起关于这世界里，时间的bug。 他说，这世界极有可能是在一个环形循环之中。说罢他从怀里掏出一把刀，却正是奇虎派的那把三百六十度环形刀刃。 他说你看这把刀，我派毕生所愿，即是参透这世界的圆之循环，重新编码，到时候天下唾手可得。 我说，我不想要什么天下，我只要一个女人。 红衣人哈哈大笑，说，那你加入我们，来我奇虎参透这世界运行之时最底层的命令，参透这循环，说不定你就能重新遇到那个女人。 对，我没有犹豫，我答应了。 他说，他叫周红衣。 六丶 我就这么加入了奇虎三六零。 彼时奇虎正在重整旗鼓，周红衣想要东山再起，他不能少了我这个助力。 从此我手里多了一把，三百六十度的，环形刀刃。 萧萧狼烟，江湖恩怨再起。 人在江湖，真的身不由己。 我一边参悟奇虎派祖传的代码跟算法，一边帮奇虎派征战天下。 我是知乎派出身，根正苗红，师傅知我落入魔教之手，吐出一口老血。孽徒，孽徒啊。他们也曾劝降，但我不为所动。 我心中，有我自己的编程之道。 所以我很清楚自己在干什么。我很清楚，男孩子，要坚强。 奇虎的势力扩张得很快，但正邪势不两立，BAT三大派见天下形势如此，便要集结程序员部队，重新再上一次光明顶。 他们说，一百年前能灭的，现在也能灭。 光明顶，是我奇虎派的大本营。 而他们带队之人，正是当今天下排行第一的程序员，出身知乎、神龙见首不见尾的大师兄。 大师兄，真的好久不见。 说实话，虽从一开始，我便知道自己背负的是什么，但我也并未想过，有一天要跟大师兄动手。也许在成为男人的路上，杀死偶像，都是不可避免的一环。 大师兄还是酒壶一把，桀骜不驯。他说傻小子，你现在过来，还真的来得及。 我说大师兄，皇皇天下，哪有什么正邪分家。无非是你来我往，你抢我杀。咱们做程序员的都知道，手底下见真章。 大师兄喝酒，哈哈大笑，他说你有长进，然后把酒壶朝天一扔。 Talk is cheap，show me the code。 七丶 与大师兄交战之前，我正参悟到这个世界代码的一些关键之处。 如今一战，倒是针尖对麦芒。大师兄的编程能力，已然步入化境。代码不在手上，已在心中。物质都是数据，规则都是代码，一时间天地轰隆，流云沐风皆能当锋利兵器，重力气压都能做任意改变，我跟大师兄从天到地，战了个平分秋色。 大师兄说，没想到你小子这么难缠。 大师兄说，对不起，我必须解决掉你。 为了正义。 我从没见他说过对不起，这正如他一定会放一个前所未见的大招一样可怕。 大师兄操纵无数代码，打入大地之中，蓦地瞬间，我感觉脚底重力似乎加大了无数倍。 好沉。 好一个无限重力流。 我们这边的程序员，要么被强大重力挤压变形，最舒服的也寸步不能动弹。 大师兄竟然还没有结束，他接着操纵无数代码，打入遥远天空之中，竟从无垠星海之中召来巨大陨石。 陨石当空，重力无限。 这两者相结合，他竟凭他一人之力，要横扫整个奇虎。 不愧是天下第一的旷世奇才。我承认，面对这样的攻势，我并没有什么好的办法。 但我也不后悔。 既然踏上这条路，我就没有打算过回头。 陨石从我头上落下之时，生死交错的瞬间，我仿佛又看到结衣的脸，像电影一般飞驰而过的场面。 我突然领悟到些什么。 我在那一瞬也打出无数代码，我打出的代码，跟大师兄的，一模一样。 复制代码，通常比较容易。 我脚下重力瞬间又加大无数倍，其他的程序员早已不堪重负，化为一摊数据流。而那个陨石速度越来越快，擦出巨大的热浪火花，空间都变形扭曲，周围一切化为粉末，消散无形。 我以为那个瞬间我已经死了。 而我在那一个瞬间，看到了在弯曲变形的前方，有一个时空的奇点。 时间是一个圆。 我靠近它，向死而生。 前方白光一片。 八丶 我睁开眼。 眼前是那个熟悉的酒馆。 我走进去，一个风情万种的女人转过来。 她问我，客官，你要喝点什么嘛？ 完。","tags":[{"name":"noting","slug":"noting","permalink":"https:fengjisen.github.io/tags/noting/"}]},{"title":"Activiti数据库表结构","date":"2017-05-27T05:54:28.000Z","path":"2017/05/27/Activiti数据库表结构/","text":"废话少说 先来两张数据库的表结构图吧 Execution 执行对象 按流程定义的规则执行一次的过程. 对应的表： act_ru_execution： 正在执行的信息 act_hi_procinst：已经执行完的历史流程实例信息 act_hi_actinst：存放历史所有完成的活动ProcessInstance 流程实例 特指流程从开始到结束的那个最大的执行分支，一个执行的流程中，流程实例只有1个。 注意 （1）如果是单例流程，执行对象ID就是流程实例ID （2）如果一个流程有分支和聚合，那么执行对象ID和流程实例ID就不相同 （3）一个流程中，流程实例只有1个，执行对象可以存在多个。 Task 任务 执行到某任务环节时生成的任务信息。 对应的表： act_ru_task：正在执行的任务信息 act_hi_taskinst：已经执行完的历史任务信息","tags":[{"name":"activiti工作流","slug":"activiti工作流","permalink":"https:fengjisen.github.io/tags/activiti工作流/"}]},{"title":"探索activiti中的23张表","date":"2017-05-26T04:08:21.000Z","path":"2017/05/26/探索activiti中的23张表/","text":"数据库Activiti数据库支持：Activiti的后台是有数据库的支持，所有的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。用途也和服务的API对应。 ACTRE*: ‘RE’表示repository。 这个前缀的表包含了流程定义和流程静态资源（图片，规则，等等）。 ACTRU*: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。 ACTID*: ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等。 ACTHI: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例，变量，任务等等。ACTGE: 通用数据， 用于不同场景下，如存放资源文件。 表结构操作：资源库流程规则表 1)act_re_deployment 部署信息表 2)act_re_model 流程设计模型部署表 3)act_re_procdef 流程定义数据表 运行时数据库表 1)act_ru_execution 运行时流程执行实例表 2)act_ru_identitylink 运行时流程人员表，主要存储任务节点与参与者的相关信息 3)act_ru_task 运行时任务节点表 4)act_ru_variable 运行时流程变量数据表 历史数据库表 1)act_hi_actinst 历史节点表 2)act_hi_attachment 历史附件表 3)act_hi_comment 历史意见表 4)act_hi_identitylink 历史流程人员表 5)act_hi_detail 历史详情表，提供历史变量的查询 6)act_hi_procinst 历史流程实例表 7)act_hi_taskinst 历史任务实例表 8)act_hi_varinst 历史变量表 组织机构表 1)act_id_group 用户组信息表 2)act_id_info 用户扩展信息表 3)act_id_membership 用户与用户组对应信息表 4)act_id_user 用户信息表 这四张表很常见，基本的组织机构管理，关于用户认证方面建议还是自己开发一套，组件自带的功能太简单，使用中有很多需求难以满足 通用数据表 1)act_ge_bytearray 二进制数据表 2)act_ge_property 属性数据表存储整个流程引擎级别的数据,初始化表结构时，会默认插入三条记录， bpmn文件 BPMN 2.0根节点是definitions节点。 这个元素中，可以定义多个流程定义（不过我们建议每个文件只包含一个流程定义， 可以简化开发过程中的维护难度）。 一个空的流程定义看起来像下面这样。注意，definitions元素 最少也要包含xmlns 和 targetNamespace的声明。 targetNamespace可以是任意值，它用来对流程实例进行分类 部署流程定义（classpath路径加载文件） 1)先获取流程引擎对象：在创建时会自动加载classpath下的activiti.cfg.xml2)首先获得默认的流程引擎，通过流程引擎获取了一个RepositoryService对象（仓库对象）3)由仓库的服务对象产生一个部署对象配置对象，用来封装部署操作的相关配置4)这是一个链式编程，在部署配置对象中设置显示名，上传流程定义规则文件5)向数据库表中存放流程定义的规则信息。6)这一步在数据库中将操作三张表：a)act_re_deployment（部署对象表） 存放流程定义的显示名和部署时间，每部署一次增加一条记录 b)act_re_procdef（流程定义表） 存放流程定义的属性信息，部署每个新的流程定义都会在这张表中增加一条记录。 注意：当流程定义的key相同的情况下，使用的是版本升级 c)act_ge_bytearray（资源文件表） 存储流程定义相关的部署信息。即流程定义文档的存放地。每部署一次就会增加两条记录，一条是关于bpmn规则文件的，一条是图片的（如果部署时只指定了bpmn一个文件，activiti会在部署时解析bpmn文件内容自动生成流程图）。两个文件不是很大，都是以二进制形式存储在数据库中。 但是部署bpmn文件时不建议直接部署bpmn文件 建议和png文件打成zip包在部署","tags":[{"name":"activiti工作流","slug":"activiti工作流","permalink":"https:fengjisen.github.io/tags/activiti工作流/"}]},{"title":"activiti","date":"2017-05-25T14:34:43.000Z","path":"2017/05/25/activiti-0/","text":"工作流（Workflow)就是业务过程的部分或整体在计算机应用环境下的自动化主要解决的是“使在多个参与者之间按照某种定义的规则传递文档，信息或任务的过程自动进行，从而实现某个预期的业务目标，或者促使此目标的实现” 工作流管理系统（WFMS）是一个软件系统，它完成工作量的定义和管理，并按照在系统中预先定义好的工作流规则进行工作流实例的执行。工作流管理系统不是企业的业务系统，而是为企业的业务系统的运行提供了一个软件的支撑环境 工作流管理系统的目标管理工作的流程以确保工作在正确的时间被期望的人员所执行——在自动化进行的业务过程中插入人工的执行和干预 Activiti介绍Activiti5是由Alfresco软件在2010年5月17日发布的业务流程管理（BPM）框架，它是覆盖了业务流程管理、工作流、服务协作等领域的一个开源的、灵活的、易扩展的可执行流程语言框架。Activiti基于Apache许可的开源BPM平台，创始人Tom Baeyens是JBoss jBPM的项目架构师，它特色是提供了eclipse插件，开发人员可以通过插件直接绘画出业务 工作流引擎ProcessEngine对象，这是Activiti工作的核心。负责生成流程运行时的各种实例及数据、监控和管理流程的运行。 BPMN业务流程建模与标注（Business Process Model and Notation，BPMN) ，描述流程的基本符号，包括这些图元如何组合成一个业务流程图（Business Process Diagram） 核心配置文件 activiti.cfg.xml &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&gt; &lt;!-- ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration(); //连接数据库的配置 processEngineConfiguration.setJdbcDriver(&quot;com.mysql.jdbc.Driver&quot;); processEngineConfiguration.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/itcast0711activiti?useUnicode=true&amp;characterEncoding=utf8&quot;); processEngineConfiguration.setJdbcUsername(&quot;root&quot;); processEngineConfiguration.setJdbcPassword(&quot;root&quot;); /** public static final String DB_SCHEMA_UPDATE_FALSE = &quot;false&quot;;不能自动创建表，需要表存在 public static final String DB_SCHEMA_UPDATE_CREATE_DROP = &quot;create-drop&quot;;先删除表再创建表 public static final String DB_SCHEMA_UPDATE_TRUE = &quot;true&quot;;如果表不存在，自动创建表 */ processEngineConfiguration.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE); --&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;!-- 连接数据的配置 --&gt; &lt;property name=&quot;jdbcDriver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/itcast0711activiti?useUnicode=true&amp;amp;characterEncoding=utf8&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUsername&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcPassword&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;!-- 没有表创建表 --&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 看到这里不得不感叹一下spring的强大，整合了java半壁江山 数据库初始化数据库方法一： //创建工作流需要的数据库 @Test public void createTable(){ ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration(); configuration.setJdbcDriver(&quot;com.mysql.jdbc.Driver&quot;); configuration.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/activiti&quot;); configuration.setJdbcUsername(&quot;root&quot;); configuration.setJdbcPassword(&quot;12345678&quot;); /** public static final String DB_SCHEMA_UPDATE_FALSE = &quot;false&quot;;不能自动创建表，需要表存在 public static final String DB_SCHEMA_UPDATE_CREATE_DROP = &quot;create-drop&quot;;先删除表再创建表 public static final String DB_SCHEMA_UPDATE_TRUE = &quot;true&quot;;如果表不存在，自动创建表 */ configuration.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE); //工作流的核心对象，ProcessEnginee对象 ProcessEngine processEngine = configuration.buildProcessEngine(); System.out.println(&quot;processEngine:&quot;+processEngine); } 方法二： 由于方法一要有代码比较麻烦，所以有配置文件替代：activiti.cfg.xml &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&gt; &lt;!-- ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration(); //连接数据库的配置 processEngineConfiguration.setJdbcDriver(&quot;com.mysql.jdbc.Driver&quot;); processEngineConfiguration.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/itcast0711activiti?useUnicode=true&amp;characterEncoding=utf8&quot;); processEngineConfiguration.setJdbcUsername(&quot;root&quot;); processEngineConfiguration.setJdbcPassword(&quot;root&quot;); /** public static final String DB_SCHEMA_UPDATE_FALSE = &quot;false&quot;;不能自动创建表，需要表存在 public static final String DB_SCHEMA_UPDATE_CREATE_DROP = &quot;create-drop&quot;;先删除表再创建表 public static final String DB_SCHEMA_UPDATE_TRUE = &quot;true&quot;;如果表不存在，自动创建表 */ processEngineConfiguration.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE); --&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;!-- 连接数据的配置 --&gt; &lt;property name=&quot;jdbcDriver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/itcast0711activiti?useUnicode=true&amp;amp;characterEncoding=utf8&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUsername&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcPassword&quot; value=&quot;12345678&quot;&gt;&lt;/property&gt; &lt;!-- 没有表创建表 --&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; /**使用配置文件创建工作流需要的23张表*/ @Test public void createTable_2(){ // ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;); // //工作流的核心对象，ProcessEnginee对象 // ProcessEngine processEngine = processEngineConfiguration.buildProcessEngine(); ProcessEngine processEngine = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;) // .buildProcessEngine(); System.out.println(&quot;processEngine:&quot;+processEngine); } Activiti用来存放流程数据一共使用了23张表 都是以Act_开头的 底层操作使用的mybatis操作 工作流Activiti的表是用来存储流程数据的 而业务数据都需要用户自己创建和维护 一定要让业务去关联流程 才能关联工作流系统 API流程引擎ProcessEngine对象在Activiti中最核心的类，其他的类都是由他而来。 由流程引擎ProcessEngine对象创建各个Service,这些Service是调用工作流23张表的服务 RepositoryService 管理流程定义RuntimeService 执行管理，包括启动，推进，删除流程实例等操作TaskService 任务管理HistoryService 历史管理（执行完的数据的管理）IdentityService 组织机构管理FormService 一个可选服务，任务表单管理ManagerService 流程的执行过程 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); /**部署流程定义*/ @Test public void deploymentProcessDefinition(){ Deployment deployment = processEngine.getRepositoryService()//与流程定义和部署对象相关的Service .createDeployment()//创建一个部署对象 .name(&quot;helloworld入门程序&quot;)//添加部署的名称 .addClasspathResource(&quot;diagrams/helloworld.bpmn&quot;)//从classpath的资源中加载，一次只能加载一个文件 .addClasspathResource(&quot;diagrams/helloworld.png&quot;)//从classpath的资源中加载，一次只能加载一个文件 .deploy();//完成部署 System.out.println(&quot;部署ID：&quot;+deployment.getId());//1 System.out.println(&quot;部署名称：&quot;+deployment.getName());//helloworld入门程序 } /**启动流程实例*/ @Test public void startProcessInstance(){ //流程定义的key String processDefinitionKey = &quot;helloword&quot;; ProcessInstance pi = processEngine.getRuntimeService()//与正在执行的流程实例和执行对象相关的Service .startProcessInstanceByKey(processDefinitionKey);//使用流程定义的key启动流程实例，key对应helloworld.bpmn文件中id的属性值，使用key值启动，默认是按照最新版本的流程定义启动 System.out.println(&quot;流程实例ID:&quot;+pi.getId());//流程实例ID 101 System.out.println(&quot;流程定义ID:&quot;+pi.getProcessDefinitionId());//流程定义ID helloworld:1:4 } /**查询当前人的个人任务*/ @Test public void findMyPersonalTask(){ String assignee = &quot;张三&quot;; List&lt;Task&gt; list = processEngine.getTaskService()//与正在执行的任务管理相关的Service .createTaskQuery()//创建任务查询对象 .taskAssignee(assignee)//指定个人任务查询，指定办理人 .list(); if(list!=null &amp;&amp; list.size()&gt;0){ for(Task task:list){ System.out.println(&quot;任务ID:&quot;+task.getId()); System.out.println(&quot;任务名称:&quot;+task.getName()); System.out.println(&quot;任务的创建时间:&quot;+task.getCreateTime()); System.out.println(&quot;任务的办理人:&quot;+task.getAssignee()); System.out.println(&quot;流程实例ID：&quot;+task.getProcessInstanceId()); System.out.println(&quot;执行对象ID:&quot;+task.getExecutionId()); System.out.println(&quot;流程定义ID:&quot;+task.getProcessDefinitionId()); System.out.println(&quot;########################################################&quot;); } } } /**完成我的任务*/ @Test public void completeMyPersonalTask(){ //任务ID String taskId = &quot;204&quot;; processEngine.getTaskService()//与正在执行的任务管理相关的Service .complete(taskId); System.out.println(&quot;完成任务：任务ID：&quot;+taskId); }","tags":[{"name":"activiti工作流","slug":"activiti工作流","permalink":"https:fengjisen.github.io/tags/activiti工作流/"}]},{"title":"青春","date":"2017-03-24T15:15:03.000Z","path":"2017/03/24/青春/","text":"18岁的时候，你觉得自己还能永远停留在这个阶段，还在惋惜青春，感叹没有做几件疯狂的事情；19岁的时候，开始学会观察这个世界，有着自己的小情绪，棱角分明，敏感而脆弱；20岁的时候，你想成为一个温和平静的人，修炼自己的心性，写下了“你已亭亭，无惧风雨”的期许；21岁的开始，你想成为一个内心强大的人，坚持自己喜欢的生活方式，距离梦想越来越近。 “我们都到了一个略显尴尬的年纪，都不再那么年轻了却也没有足够的成长；都想依靠自己却发现还差一点； 都想要往前走却发现前路漫漫，前有迷雾后有压力。但我依旧相信一些事物，我想你也同样。 有野心就去努力，在你跌倒还能站起来的时候。越是尴尬越是要面对，才能摆脱它。”","tags":[{"name":"记事","slug":"记事","permalink":"https:fengjisen.github.io/tags/记事/"}]}]